package com.clickhouse.jdbc;

import java.net.URI;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.TimeZone;

import com.clickhouse.client.ClickHouseVersion;

public interface ClickHouseConnection extends Connection {
    @Override
    default ClickHouseStatement createStatement() throws SQLException {
        return createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default ClickHouseStatement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return createStatement(resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    ClickHouseStatement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
            throws SQLException;

    @Override
    default CallableStatement prepareCall(String sql) throws SQLException {
        return prepareCall(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return prepareCall(sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
            int resultSetHoldability) throws SQLException {
        throw SqlExceptionUtils.unsupportedError("prepareCall not implemented");
    }

    @Override
    default PreparedStatement prepareStatement(String sql) throws SQLException {
        return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        if (autoGeneratedKeys != Statement.NO_GENERATED_KEYS) {
            // not entirely true, what if the table engine is JDBC?
            throw SqlExceptionUtils.unsupportedError("Only NO_GENERATED_KEYS is supported");
        }

        return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        // not entirely true, what if the table engine is JDBC?
        throw SqlExceptionUtils.unsupportedError("ClickHouse does not support auto generated keys");
    }

    @Override
    default PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        // not entirely true, what if the table engine is JDBC?
        throw SqlExceptionUtils.unsupportedError("ClickHouse does not support auto generated keys");
    }

    @Override
    default PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        return prepareStatement(sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    /**
     * Gets current database. {@link #getSchema()} is similar but it will check if
     * connection is closed or not hence may throw {@link SQLException}.
     *
     * @return non-null database name
     */
    String getCurrentDatabase();

    /**
     * Gets current user.
     *
     * @return non-null user name
     */
    String getCurrentUser();

    TimeZone getEffectiveTimeZone();

    TimeZone getServerTimeZone();

    ClickHouseVersion getServerVersion();

    URI getUri();

    boolean isJdbcCompliant();

    String newQueryId();
}
